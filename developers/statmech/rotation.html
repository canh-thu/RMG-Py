

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.2. Rotational degrees of freedom &mdash; RMG Py 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="RMG Py 0.1.0 documentation" href="../../index.html" />
    <link rel="up" title="7. Statistical mechanics in RMG" href="index.html" />
    <link rel="next" title="7.3. Vibrational degrees of freedom" href="vibration.html" />
    <link rel="prev" title="7.1. Translational degrees of freedom" href="translation.html" /> 
  </head>
  <body>
<div class="header">
&nbsp;
</div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vibration.html" title="7.3. Vibrational degrees of freedom"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="translation.html" title="7.1. Translational degrees of freedom"
             accesskey="P">previous</a> |</li>
<li><a href="../../index.html">Documentation</a> &raquo;</li>

          <li><a href="../index.html" >RMG Developer&#8217;s Guide</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">7. Statistical mechanics in RMG</a> &raquo;</li> 
      </ul>
    </div>
            
  <div class="section" id="rotational-degrees-of-freedom">
<h1>7.2. Rotational degrees of freedom<a class="headerlink" href="#rotational-degrees-of-freedom" title="Permalink to this headline">¶</a></h1>
<p>Rotational motion describes external rotation of the system as a whole. For
most systems it represents three degrees of freedom (one per dimension of
motion). However, linear systems have one less degree of rotational freedom,
as rotation about the linear axis of the system does not result in any movement.</p>
<div class="section" id="linear-rotors">
<h2>7.2.1. Linear rotors<a class="headerlink" href="#linear-rotors" title="Permalink to this headline">¶</a></h2>
<p>A linear rigid rotor is modeled as a pair of point masses <span class="math">\(m_1\)</span> and
<span class="math">\(m_2\)</span> separated by a distance <span class="math">\(R\)</span>. Since we are modeling the
rotation of this system, we choose to work in spherical coordinates. Following
the physics convention &#8211; where <span class="math">\(0 \le \theta \le \pi\)</span> is the zenith
angle and <span class="math">\(0 \le \phi \le 2\pi\)</span> is the azimuth &#8211; the Schrodinger
equation for the rotor is given by</p>
<div class="math">
\[\begin{split}-\frac{\hbar^2}{2I} \left[ \frac{1}{\sin \theta} \frac{\partial}{\partial \theta} \left( \sin \theta \frac{\partial}{\partial \theta} \right) + \frac{1}{\sin^2 \theta} \frac{\partial^2}{\partial \phi^2} \right] \Psi(\theta, \phi) &amp;= E \Psi(\theta, \phi)\end{split}\]</div>
<p>where <span class="math">\(I \equiv \mu R^2\)</span> is the moment of inertia of the rotating body,
and <span class="math">\(\mu \equiv m_1 m_2 / (m_1 + m_2)\)</span> is the reduced mass. Note that
there is no potential term in the above expression; for this reason, a rigid
rotor is often referred to as a <em>free</em> rotor. Solving the Schrodinger equation
gives the energy levels <span class="math">\(E_J\)</span> and corresponding degeneracies <span class="math">\(g_J\)</span>
for the linear rigid rotor as</p>
<div class="math">
\[\begin{split}E_J &amp;= B J (J + 1) \hspace{2em} J = 0, 1, 2, \ldots \\
g_J &amp;= 2J + 1\end{split}\]</div>
<p>where <span class="math">\(J\)</span> is the quantum number for the rotor &#8211; sometimes called the
total angular momentum quantum number &#8211; and <span class="math">\(B \equiv \hbar^2/2I\)</span> is the
rotational constant.</p>
<p>Using these expressions for the energy levels and corresponding degeneracies,
we can evaluate the partition function for the linear rigid rotor:</p>
<div class="math">
\[Q_\mathrm{rot}(T) = \frac{1}{\sigma} \sum_{J=0}^\infty (2J + 1) e^{- B J (J + 1) / k_\mathrm{B} T}\]</div>
<p>In many cases the temperature of interest is large relative to the energy
spacing; in this limit we can obtain a closed-form analytical expression
for the linear rotor partition function in the classical limit:</p>
<div class="math">
\[Q_\mathrm{rot}^\mathrm{cl}(T) = \frac{1}{\sigma} \frac{8 \pi^2 I k_\mathrm{B} T}{h^2}\]</div>
<p>Above we have also introduced <span class="math">\(\sigma\)</span> as the symmetry number of the
rigid rotor.</p>
<p>In RMG, the rotational motion of a linear system represented using the
<a class="reference internal" href="#rmgpy.statmech.LinearRotor" title="rmgpy.statmech.LinearRotor"><tt class="xref py py-class docutils literal"><span class="pre">LinearRotor</span></tt></a> class.</p>
<dl class="class">
<dt id="rmgpy.statmech.LinearRotor">
<em class="property">class </em><tt class="descclassname">rmgpy.statmech.</tt><tt class="descname">LinearRotor</tt><a class="headerlink" href="#rmgpy.statmech.LinearRotor" title="Permalink to this definition">¶</a></dt>
<dd><p>LinearRotor(inertia=None, symmetry=1, quantum=False, rotationalConstant=None)</p>
<p>A statistical mechanical model of a two-dimensional (linear) rigid rotor.
The attributes are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>inertia</cite></td>
<td>The moment of inertia of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>rotationalConstant</cite></td>
<td>The rotational constant of the rotor</td>
</tr>
<tr class="row-even"><td><cite>symmetry</cite></td>
<td>The symmetry number of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>quantum</cite></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> to use the quantum mechanical model, <tt class="docutils literal"><span class="pre">False</span></tt> to use the classical model</td>
</tr>
</tbody>
</table>
<p>Note that the moment of inertia and the rotational constant are simply two
ways of representing the same quantity; only one of these can be specified
independently.</p>
<p>In the majority of chemical applications, the energies involved in the
rigid rotor place it very nearly in the classical limit at all relevant
temperatures; therefore, the classical model is used by default.</p>
<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getDensityOfStates">
<tt class="descname">getDensityOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray densStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getDensityOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density of states <span class="math">\(\rho(E) \ dE\)</span> at the specified
energies <cite>Elist</cite> in J/mol above the ground state. If an initial density
of states <cite>densStates0</cite> is given, the rotor density of states will be
convoluted into these states.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getEnthalpy">
<tt class="descname">getEnthalpy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getEnthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enthalpy in J/mol for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getEntropy">
<tt class="descname">getEntropy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getEntropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entropy in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getHeatCapacity">
<tt class="descname">getHeatCapacity</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getHeatCapacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the heat capacity in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getLevelDegeneracy">
<tt class="descname">getLevelDegeneracy</tt><big>(</big><em>self</em>, <em>int J</em><big>)</big> &rarr; int<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getLevelDegeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degeneracy of level <cite>J</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getLevelEnergy">
<tt class="descname">getLevelEnergy</tt><big>(</big><em>self</em>, <em>int J</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getLevelEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the energy of level <cite>J</cite> in kJ/mol.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getPartitionFunction">
<tt class="descname">getPartitionFunction</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getPartitionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the partition function <span class="math">\(Q(T)\)</span> at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.LinearRotor.getSumOfStates">
<tt class="descname">getSumOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray sumStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.LinearRotor.getSumOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of states <span class="math">\(N(E)\)</span> at the specified energies <cite>Elist</cite>
in J/mol above the ground state. If an initial sum of states 
<cite>sumStates0</cite> is given, the rotor sum of states will be convoluted into
these states.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.LinearRotor.inertia">
<tt class="descname">inertia</tt><a class="headerlink" href="#rmgpy.statmech.LinearRotor.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The moment of inertia of the rotor.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.LinearRotor.rotationalConstant">
<tt class="descname">rotationalConstant</tt><a class="headerlink" href="#rmgpy.statmech.LinearRotor.rotationalConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>The rotational constant of the rotor.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nonlinear-rotors">
<h2>7.2.2. Nonlinear rotors<a class="headerlink" href="#nonlinear-rotors" title="Permalink to this headline">¶</a></h2>
<p>A nonlinear rigid rotor is the generalization of the linear rotor to a
nonlinear polyatomic system. Such a system is characterized by three moments
of inertia <span class="math">\(I_\mathrm{A}\)</span>, <span class="math">\(I_\mathrm{B}\)</span>, and <span class="math">\(I_\mathrm{C}\)</span> instead of just one.
The solution to the Schrodinger equation for the quantum nonlinear rotor is not
well defined, so we will simply show the classical result instead:</p>
<div class="math">
\[Q_\mathrm{rot}^\mathrm{cl}(T) = \frac{\pi^{1/2}}{\sigma} \left( \frac{8 k_\mathrm{B} T}{h^2} \right)^{3/2} \sqrt{I_\mathrm{A} I_\mathrm{B} I_\mathrm{C}}\]</div>
<p>In RMG, the rotational motion of a nonlinear system represented using the
<a class="reference internal" href="#rmgpy.statmech.NonlinearRotor" title="rmgpy.statmech.NonlinearRotor"><tt class="xref py py-class docutils literal"><span class="pre">NonlinearRotor</span></tt></a> class.</p>
<dl class="class">
<dt id="rmgpy.statmech.NonlinearRotor">
<em class="property">class </em><tt class="descclassname">rmgpy.statmech.</tt><tt class="descname">NonlinearRotor</tt><a class="headerlink" href="#rmgpy.statmech.NonlinearRotor" title="Permalink to this definition">¶</a></dt>
<dd><p>NonlinearRotor(inertia=None, symmetry=1, quantum=False, rotationalConstant=None)</p>
<p>A statistical mechanical model of an N-dimensional nonlinear rigid rotor.
The attributes are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>inertia</cite></td>
<td>The moments of inertia of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>rotationalConstant</cite></td>
<td>The rotational constants of the rotor</td>
</tr>
<tr class="row-even"><td><cite>symmetry</cite></td>
<td>The symmetry number of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>quantum</cite></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> to use the quantum mechanical model, <tt class="docutils literal"><span class="pre">False</span></tt> to use the classical model</td>
</tr>
</tbody>
</table>
<p>Note that the moments of inertia and the rotational constants are simply two
ways of representing the same quantity; only one set of these can be 
specified independently.</p>
<p>In the majority of chemical applications, the energies involved in the
rigid rotor place it very nearly in the classical limit at all relevant
temperatures; therefore, the classical model is used by default. In the
current implementation, the quantum mechanical model has not been 
implemented, and a <tt class="xref py py-class docutils literal"><span class="pre">NotImplementedError</span></tt> will be raised if you try
to use it.</p>
<dl class="method">
<dt id="rmgpy.statmech.NonlinearRotor.getDensityOfStates">
<tt class="descname">getDensityOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray densStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.getDensityOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density of states <span class="math">\(\rho(E) \ dE\)</span> at the specified
energies <cite>Elist</cite> in J/mol above the ground state. If an initial density
of states <cite>densStates0</cite> is given, the rotor density of states will be
convoluted into these states.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.NonlinearRotor.getEnthalpy">
<tt class="descname">getEnthalpy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.getEnthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enthalpy in J/mol for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.NonlinearRotor.getEntropy">
<tt class="descname">getEntropy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.getEntropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entropy in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.NonlinearRotor.getHeatCapacity">
<tt class="descname">getHeatCapacity</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.getHeatCapacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the heat capacity in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.NonlinearRotor.getPartitionFunction">
<tt class="descname">getPartitionFunction</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.getPartitionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the partition function <span class="math">\(Q(T)\)</span> at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.NonlinearRotor.getSumOfStates">
<tt class="descname">getSumOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray sumStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.getSumOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of states <span class="math">\(N(E)\)</span> at the specified energies <cite>Elist</cite>
in J/mol above the ground state. If an initial sum of states 
<cite>sumStates0</cite> is given, the rotor sum of states will be convoluted into
these states.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.NonlinearRotor.inertia">
<tt class="descname">inertia</tt><a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The moments of inertia of the rotor.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.NonlinearRotor.rotationalConstant">
<tt class="descname">rotationalConstant</tt><a class="headerlink" href="#rmgpy.statmech.NonlinearRotor.rotationalConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>The rotational constant of the rotor.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="k-rotors">
<h2>7.2.3. K-rotors<a class="headerlink" href="#k-rotors" title="Permalink to this headline">¶</a></h2>
<p>A K-rotor is simply the one-dimensional equivalent of a linear rigid rotor.
The energy levels <span class="math">\(E_K\)</span> of the K-rotor are given by</p>
<div class="math">
\[\begin{split}E_K &amp;= B K^2 \hspace{2em} K = 0, \pm 1, \pm 2, \ldots\end{split}\]</div>
<p>where <span class="math">\(K\)</span> is the quantum number for the rotor and
<span class="math">\(B \equiv \hbar^2/2I\)</span> is the rotational constant.</p>
<p>Using these expressions for the energy levels and corresponding degeneracies,
we can evaluate the partition function for the K-rotor:</p>
<div class="math">
\[Q_\mathrm{rot}(T) = \frac{1}{\sigma} \left( 1 + \sum_{K=1}^\infty 2 e^{- B K^2 / k_\mathrm{B} T} \right)\]</div>
<p>In many cases the temperature of interest is large relative to the energy
spacing; in this limit we can obtain a closed-form analytical expression
for the linear rotor partition function in the classical limit:</p>
<div class="math">
\[Q_\mathrm{rot}^\mathrm{cl}(T) = \frac{1}{\sigma} \left( \frac{8 \pi^2 I k_\mathrm{B} T}{h^2} \right)^{1/2}\]</div>
<p>where <span class="math">\(\sigma\)</span> is the symmetry number of the K-rotor.</p>
<p>In RMG, the rotational motion of a K-rotor is represented using the
<a class="reference internal" href="#rmgpy.statmech.KRotor" title="rmgpy.statmech.KRotor"><tt class="xref py py-class docutils literal"><span class="pre">KRotor</span></tt></a> class.</p>
<dl class="class">
<dt id="rmgpy.statmech.KRotor">
<em class="property">class </em><tt class="descclassname">rmgpy.statmech.</tt><tt class="descname">KRotor</tt><a class="headerlink" href="#rmgpy.statmech.KRotor" title="Permalink to this definition">¶</a></dt>
<dd><p>KRotor(inertia=None, symmetry=1, quantum=False, rotationalConstant=None)</p>
<p>A statistical mechanical model of an active K-rotor (a one-dimensional
rigid rotor). The attributes are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>inertia</cite></td>
<td>The moment of inertia of the rotor in amu*angstrom^2</td>
</tr>
<tr class="row-odd"><td><cite>rotationalConstant</cite></td>
<td>The rotational constant of the rotor in cm^-1</td>
</tr>
<tr class="row-even"><td><cite>symmetry</cite></td>
<td>The symmetry number of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>quantum</cite></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> to use the quantum mechanical model, <tt class="docutils literal"><span class="pre">False</span></tt> to use the classical model</td>
</tr>
</tbody>
</table>
<p>Note that the moment of inertia and the rotational constant are simply two
ways of representing the same quantity; only one of these can be specified
independently.</p>
<p>In the majority of chemical applications, the energies involved in the
K-rotor place it very nearly in the classical limit at all relevant
temperatures; therefore, the classical model is used by default.</p>
<dl class="method">
<dt id="rmgpy.statmech.KRotor.getDensityOfStates">
<tt class="descname">getDensityOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray densStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.KRotor.getDensityOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density of states <span class="math">\(\rho(E) \ dE\)</span> at the specified
energies <cite>Elist</cite> in J/mol above the ground state. If an initial density
of states <cite>densStates0</cite> is given, the rotor density of states will be
convoluted into these states.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getEnthalpy">
<tt class="descname">getEnthalpy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.KRotor.getEnthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enthalpy in J/mol for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getEntropy">
<tt class="descname">getEntropy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.KRotor.getEntropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entropy in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getHeatCapacity">
<tt class="descname">getHeatCapacity</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.KRotor.getHeatCapacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the heat capacity in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getLevelDegeneracy">
<tt class="descname">getLevelDegeneracy</tt><big>(</big><em>self</em>, <em>int J</em><big>)</big> &rarr; int<a class="headerlink" href="#rmgpy.statmech.KRotor.getLevelDegeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degeneracy of level <cite>J</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getLevelEnergy">
<tt class="descname">getLevelEnergy</tt><big>(</big><em>self</em>, <em>int J</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.KRotor.getLevelEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the energy of level <cite>J</cite> in kJ/mol.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getPartitionFunction">
<tt class="descname">getPartitionFunction</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.KRotor.getPartitionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the partition function <span class="math">\(Q(T)\)</span> at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.KRotor.getSumOfStates">
<tt class="descname">getSumOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray sumStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.KRotor.getSumOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of states <span class="math">\(N(E)\)</span> at the specified energies <cite>Elist</cite>
in J/mol above the ground state. If an initial sum of states 
<cite>sumStates0</cite> is given, the rotor sum of states will be convoluted into
these states.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.KRotor.inertia">
<tt class="descname">inertia</tt><a class="headerlink" href="#rmgpy.statmech.KRotor.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The moment of inertia of the rotor.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.KRotor.rotationalConstant">
<tt class="descname">rotationalConstant</tt><a class="headerlink" href="#rmgpy.statmech.KRotor.rotationalConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>The rotational constant of the rotor.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="spherical-top-rotors">
<h2>7.2.4. Spherical top rotors<a class="headerlink" href="#spherical-top-rotors" title="Permalink to this headline">¶</a></h2>
<p>A spherical top rotor is simply the three-dimensional equivalent of a linear
rigid rotor. Unlike the nonlinear rotor, all three moments of inertia of a
spherical top are equal, i.e. <span class="math">\(I_\mathrm{A} = I_\mathrm{B} = I_\mathrm{C} = I\)</span>.
The energy levels <span class="math">\(E_J\)</span> and corresponding degeneracies <span class="math">\(g_J\)</span> of the
spherial top rotor are given by</p>
<div class="math">
\[\begin{split}E_J &amp;= B J (J + 1) \hspace{2em} J = 0, 1, 2, \ldots \\
g_J &amp;= (2J+1)^2\end{split}\]</div>
<p>where <span class="math">\(J\)</span> is the quantum number for the rotor and
<span class="math">\(B \equiv \hbar^2/2I\)</span> is the rotational constant.</p>
<p>Using these expressions for the energy levels and corresponding degeneracies,
we can evaluate the partition function for the spherical top rotor:</p>
<div class="math">
\[Q_\mathrm{rot}(T) = \frac{1}{\sigma} \sum_{J=0}^\infty (2J+1)^2 e^{- B J (J+1) / k_\mathrm{B} T}\]</div>
<p>In many cases the temperature of interest is large relative to the energy
spacing; in this limit we can obtain a closed-form analytical expression
for the linear rotor partition function in the classical limit:</p>
<div class="math">
\[Q_\mathrm{rot}^\mathrm{cl}(T) = \frac{1}{\sigma} \left( \frac{8 \pi^2 I k_\mathrm{B} T}{h^2} \right)^{3/2}\]</div>
<p>where <span class="math">\(\sigma\)</span> is the symmetry number of the spherical top. Note that
the above differs from the nonlinear rotor partition function by a factor of
<span class="math">\(\pi\)</span>.</p>
<p>In RMG, the rotational motion of a spherical top rotor is represented using
the <a class="reference internal" href="#rmgpy.statmech.SphericalTopRotor" title="rmgpy.statmech.SphericalTopRotor"><tt class="xref py py-class docutils literal"><span class="pre">SphericalTopRotor</span></tt></a> class.</p>
<dl class="class">
<dt id="rmgpy.statmech.SphericalTopRotor">
<em class="property">class </em><tt class="descclassname">rmgpy.statmech.</tt><tt class="descname">SphericalTopRotor</tt><a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor" title="Permalink to this definition">¶</a></dt>
<dd><p>SphericalTopRotor(inertia=None, symmetry=1, quantum=False, rotationalConstant=None)</p>
<p>A statistical mechanical model of a three-dimensional rigid rotor with a
single rotational constant: a spherical top. The attributes are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>inertia</cite></td>
<td>The moment of inertia of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>rotationalConstant</cite></td>
<td>The rotational constant of the rotor</td>
</tr>
<tr class="row-even"><td><cite>symmetry</cite></td>
<td>The symmetry number of the rotor</td>
</tr>
<tr class="row-odd"><td><cite>quantum</cite></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> to use the quantum mechanical model, <tt class="docutils literal"><span class="pre">False</span></tt> to use the classical model</td>
</tr>
</tbody>
</table>
<p>Note that the moment of inertia and the rotational constant are simply two
ways of representing the same quantity; only one of these can be specified
independently.</p>
<p>In the majority of chemical applications, the energies involved in the
rigid rotor place it very nearly in the classical limit at all relevant
temperatures; therefore, the classical model is used by default.</p>
<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getDensityOfStates">
<tt class="descname">getDensityOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray densStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getDensityOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density of states <span class="math">\(\rho(E) \ dE\)</span> at the specified
energies <cite>Elist</cite> in J/mol above the ground state. If an initial density
of states <cite>densStates0</cite> is given, the rotor density of states will be
convoluted into these states.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getEnthalpy">
<tt class="descname">getEnthalpy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getEnthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enthalpy in J/mol for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getEntropy">
<tt class="descname">getEntropy</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getEntropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entropy in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getHeatCapacity">
<tt class="descname">getHeatCapacity</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getHeatCapacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the heat capacity in J/mol*K for the degree of freedom at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getLevelDegeneracy">
<tt class="descname">getLevelDegeneracy</tt><big>(</big><em>self</em>, <em>int J</em><big>)</big> &rarr; int<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getLevelDegeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degeneracy of level <cite>J</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getLevelEnergy">
<tt class="descname">getLevelEnergy</tt><big>(</big><em>self</em>, <em>int J</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getLevelEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the energy of level <cite>J</cite> in kJ/mol.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getPartitionFunction">
<tt class="descname">getPartitionFunction</tt><big>(</big><em>self</em>, <em>double T</em><big>)</big> &rarr; double<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getPartitionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the partition function <span class="math">\(Q(T)\)</span> at the
specified temperature <cite>T</cite> in K.</p>
</dd></dl>

<dl class="method">
<dt id="rmgpy.statmech.SphericalTopRotor.getSumOfStates">
<tt class="descname">getSumOfStates</tt><big>(</big><em>self</em>, <em>ndarray Elist</em>, <em>ndarray sumStates0=None</em><big>)</big> &rarr; ndarray<a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.getSumOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of states <span class="math">\(N(E)\)</span> at the specified energies <cite>Elist</cite>
in J/mol above the ground state. If an initial sum of states 
<cite>sumStates0</cite> is given, the rotor sum of states will be convoluted into
these states.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.SphericalTopRotor.inertia">
<tt class="descname">inertia</tt><a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The moment of inertia of the rotor.</p>
</dd></dl>

<dl class="attribute">
<dt id="rmgpy.statmech.SphericalTopRotor.rotationalConstant">
<tt class="descname">rotationalConstant</tt><a class="headerlink" href="#rmgpy.statmech.SphericalTopRotor.rotationalConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>The rotational constant of the rotor.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div class="sidebarlogo">
<img src="../../_static/rmg-logo-small.png" alt="RMG" />
</div>
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.2. Rotational degrees of freedom</a><ul>
<li><a class="reference internal" href="#linear-rotors">7.2.1. Linear rotors</a></li>
<li><a class="reference internal" href="#nonlinear-rotors">7.2.2. Nonlinear rotors</a></li>
<li><a class="reference internal" href="#k-rotors">7.2.3. K-rotors</a></li>
<li><a class="reference internal" href="#spherical-top-rotors">7.2.4. Spherical top rotors</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="translation.html"
                        title="previous chapter">7.1. Translational degrees of freedom</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="vibration.html"
                        title="next chapter">7.3. Vibrational degrees of freedom</a></p>
  <h3>This Page </h3>
  <ul class="this-page-menu">
    <li><a href="https://github.com/GreenGroup/RMG-Py/blob/master/documentation/source/developers/statmech/rotation.rst"
           rel="nofollow">Edit this page</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2012, William H. Green, Richard H. West, and the RMG Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>